// Code generated by pg_gen, DO NOT EDIT.
package gen

import (
	"strconv"
	"strings"
)

type Filter struct {
	Column  string
	Operand string
	Value   any
}

func NewFilter(column, operand string, value any) Filter {
	return Filter{
		Column:  column,
		Operand: operand,
		Value:   value,
	}
}

type OrderBy struct {
	Column    string
	Direction string
}

type SelectResult[T any] struct {
	Total    uint `json:"total,omitempty"`
	Selected uint `json:"selected,omitempty"`
	Rows     []T  `json:"data,omitempty"`
}

func (sr *SelectResult[T]) First() *T {
	if len(sr.Rows) == 0 {
		return nil
	}

	return &sr.Rows[0]
}

func NewOrderBy(column, direction string) OrderBy {
	return OrderBy{
		Column:    column,
		Direction: direction,
	}
}

type SelectOptions struct {
	Limit   uint
	Offset  uint
	Where   []Filter
	OrderBy []OrderBy
}

func (so *SelectOptions) toWherePartAndValues() (string, []any) {
	if so.Where == nil {
		return "", nil
	}

	var queryBuilder strings.Builder
	var values []any

	if len(so.Where) > 0 {
		queryBuilder.WriteString(" WHERE ")

		for i, filter := range so.Where {
			queryBuilder.WriteString(filter.Column)
			queryBuilder.WriteString(" ")
			queryBuilder.WriteString(filter.Operand)
			queryBuilder.WriteString(" $")
			queryBuilder.WriteString(strconv.Itoa(i + 1))

			if i < (len(so.Where) - 1) {
				queryBuilder.WriteString(" AND ")
			}

			values = append(values, filter.Value)
		}
	}

	return queryBuilder.String(), values
}

func (so *SelectOptions) toOrderByPart() string {
	if so.OrderBy == nil {
		return ""
	}

	var queryBuilder strings.Builder

	if len(so.OrderBy) > 0 {
		queryBuilder.WriteString(" ORDER BY ")

		for i, order := range so.OrderBy {
			queryBuilder.WriteString(order.Column)
			queryBuilder.WriteString(" ")
			queryBuilder.WriteString(order.Direction)

			if i < (len(so.Where) - 1) {
				queryBuilder.WriteString(", ")
			}
		}
	}

	return queryBuilder.String()
}

func (so *SelectOptions) toLimitOffsetPart() string {
	if so.Limit == 0 {
		return ""
	}

	var queryBuilder strings.Builder

	queryBuilder.WriteString(" LIMIT ")
	queryBuilder.WriteString(strconv.Itoa(int(so.Limit)))

	if so.Offset > 0 {
		queryBuilder.WriteString(" OFFSET ")
		queryBuilder.WriteString(strconv.Itoa(int(so.Offset)))
	}

	return queryBuilder.String()
}

type UpdateOptions struct {
	Where []Filter
}

func (so *UpdateOptions) toWherePartAndValues() (string, []any) {
	if so.Where == nil {
		return "", nil
	}

	var queryBuilder strings.Builder
	var values []any

	if len(so.Where) > 0 {
		queryBuilder.WriteString(" WHERE ")

		for i, filter := range so.Where {
			queryBuilder.WriteString(filter.Column)
			queryBuilder.WriteString(" ")
			queryBuilder.WriteString(filter.Operand)
			queryBuilder.WriteString(" $")
			queryBuilder.WriteString(strconv.Itoa(i + 1))

			if i < (len(so.Where) - 1) {
				queryBuilder.WriteString(" AND ")
			}

			values = append(values, filter.Value)
		}
	}

	return queryBuilder.String(), values
}

type DeleteOptions struct {
	Where []Filter
}

func (so *DeleteOptions) toWherePartAndValues() (string, []any) {
	if so.Where == nil {
		return "", nil
	}

	var queryBuilder strings.Builder
	var values []any

	if len(so.Where) > 0 {
		queryBuilder.WriteString(" WHERE ")

		for i, filter := range so.Where {
			queryBuilder.WriteString(filter.Column)
			queryBuilder.WriteString(" ")
			queryBuilder.WriteString(filter.Operand)
			queryBuilder.WriteString(" $")
			queryBuilder.WriteString(strconv.Itoa(i + 1))

			if i < (len(so.Where) - 1) {
				queryBuilder.WriteString(" AND ")
			}

			values = append(values, filter.Value)
		}
	}

	return queryBuilder.String(), values
}
