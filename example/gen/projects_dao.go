// Code generated by pg_gen, DO NOT EDIT.
package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jinzhu/copier"
)

type Projects struct {
	Id          uuid.UUID  `json:"id"`
	CreatedAt   *time.Time `json:"created_at"`
	Tier        any        `json:"tier"`
	Name        string     `json:"name"`
	Description *string    `json:"description"`
}

type ProjectsDAO struct{}

func (ProjectsDAO) Count(ctx context.Context, db *sql.DB, opts *SelectOptions) (uint, error) {
	query := `SELECT count(*) FROM "projects"`

	var values []any
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			values = v
		}
	}

	row := db.QueryRowContext(ctx, query, values...)
	if row.Err() != nil {
		return 0, row.Err()
	}

	var count uint
	if err := row.Scan(&count); err != nil {
		return 0, err
	}

	return count, nil
}

func (ProjectsDAO) Select(ctx context.Context, db *sql.DB, opts *SelectOptions) (*SelectResult[Projects], error) {
	query := `SELECT "id", "created_at", "tier", "name", "description" FROM "projects"`

	var values []any
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			values = v
		}

		if orderByPart := opts.toOrderByPart(); orderByPart != "" {
			query += orderByPart
		}

		if limitPart := opts.toLimitOffsetPart(); limitPart != "" {
			query += limitPart
		}
	}

	total, err := ProjectsDAO{}.Count(ctx, db, opts)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query, values...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := &SelectResult[Projects]{
		Total:    total,
		Selected: 0,
		Rows:     []Projects{},
	}

	for rows.Next() {
		var entity Projects
		if err := rows.Scan(&entity.Id, &entity.CreatedAt, &entity.Tier, &entity.Name, &entity.Description); err != nil {
			return nil, err
		}

		result.Rows = append(result.Rows, entity)
		result.Selected++
	}

	return result, nil
}

func (ProjectsDAO) Insert(ctx context.Context, tx *sql.Tx, values Projects) error {
	const query = `INSERT INTO "projects" ("id", "created_at", "tier", "name", "description") VALUES ($1::UUID, $2::TIMESTAMP, $3::PROJECT_TIER, $4::VARCHAR, $5::VARCHAR)`

	if _, err := tx.ExecContext(ctx, query, values.Id, values.CreatedAt, values.Tier, values.Name, values.Description); err != nil {
		return err
	}

	return nil
}

func (ProjectsDAO) Update(ctx context.Context, tx *sql.Tx, values Projects, opts *UpdateOptions) error {
	query := `UPDATE "projects" SET "created_at" = $2::TIMESTAMP, "tier" = $3::PROJECT_TIER, "name" = $4::VARCHAR, "description" = $5::VARCHAR`

	queryValues := []any{values.Id, values.CreatedAt, values.Tier, values.Name, values.Description}
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			queryValues = v
		}
	}

	if _, err := tx.ExecContext(ctx, query, queryValues...); err != nil {
		return err
	}

	return nil
}

func (ProjectsDAO) Delete(ctx context.Context, tx *sql.Tx, opts *DeleteOptions) error {
	query := `DELETE FROM "projects"`

	var values []any
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			values = v
		}
	}

	if _, err := tx.ExecContext(ctx, query, values...); err != nil {
		return err
	}

	return nil
}

func (ProjectsDAO) Copy(from *Projects, to any) error {
	return copier.Copy(&to, from)
}
