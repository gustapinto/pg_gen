// Code generated by pg_gen, DO NOT EDIT.
package {goPackageName}

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jinzhu/copier"
)

type {goEntityName} struct {
	{goEntityFields}
}

type {goEntityName}SelectOneResult struct {
	Data *{goEntityName} `json:"data,omitempty"`
}

type {goEntityName}SelectManyResult struct {
	Total    uint                 `json:"total,omitempty"`
	Selected uint                 `json:"selected,omitempty"`
	Data     []{goEntityName} `json:"data,omitempty"`
}

type {goEntityName}Table struct{}

func ({goEntityName}Table) CountAll(ctx context.Context, db *sql.DB) (uint, error) {
	const query = `SELECT count(*) FROM "{sqlTableName}"`

	row := db.QueryRowContext(ctx, query)
	if row.Err() != nil {
		return 0, row.Err()
	}

	var count uint
	if err := row.Scan(&count); err != nil {
		return 0, err
	}

	return count, nil
}

func ({goEntityName}Table) SelectOne(ctx context.Context, db *sql.DB, primaryKey string) (*{goEntityName}SelectOneResult, error) {
	const query = `SELECT {sqlSelectFields} FROM "{sqlTableName}" WHERE "{sqlPrimaryKeyColumn}" = $1`

	row := db.QueryRowContext(ctx, query, primaryKey)
	if row.Err() != nil {
		return nil, row.Err()
	}

	result := &{goEntityName}SelectOneResult{
		Data: &{goEntityName}{},
	}
	if err := row.Scan({goSelectOneScanFields}); err != nil {
		return nil, err
	}

	return result, nil
}

func ({goEntityName}Table) SelectMany(ctx context.Context, db *sql.DB) (*{goEntityName}SelectManyResult, error) {
	const query = `SELECT {sqlSelectFields} FROM "{sqlTableName}"`

	total, err := {goEntityName}Table{}.CountAll(ctx, db)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := &{goEntityName}SelectManyResult{
		Total:    total,
		Selected: 0,
		Data:     make([]{goEntityName}, total),
	}

	for rows.Next() {
		var entity {goEntityName}
		if err := rows.Scan({goSelectManyScanFields}); err != nil {
			return nil, err
		}

		result.Data[result.Selected] = entity
		result.Selected++
	}

	return result, nil
}

func ({goEntityName}Table) SelectManyPaginated(ctx context.Context, db *sql.DB, page, limit uint) (*{goEntityName}SelectManyResult, error) {
	const query = `SELECT {sqlSelectFields} FROM "{sqlTableName}" LIMIT $1 OFFSET $2`

	total, err := {goEntityName}Table{}.CountAll(ctx, db)
	if err != nil {
		return nil, err
	}

	offset := (page - 1) * limit
	if offset > total {
		offset = (total - limit)
	}

	rows, err := db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := &{goEntityName}SelectManyResult{
		Total:    total,
		Selected: 0,
		Data:     make([]{goEntityName}, total),
	}

	for rows.Next() {
		var entity {goEntityName}
		if err := rows.Scan({goSelectManyScanFields}); err != nil {
			return nil, err
		}

		result.Data[result.Selected] = entity
		result.Selected++
	}

	return result, nil
}

func ({goEntityName}Table) Insert(ctx context.Context, tx *sql.Tx, values {goEntityName}) error {
	const query = `INSERT INTO "{sqlTableName}" ({sqlInsertFields}) VALUES ({sqlInsertPlaceholders})`

	if _, err := tx.ExecContext(ctx, query, {goInsertValues}); err != nil {
		return err
	}

	return nil
}

func ({goEntityName}Table) Update(ctx context.Context, tx *sql.Tx, values {goEntityName}, primaryKey string) error {
	const query = `UPDATE "{sqlTableName}" SET {sqlUpdatePlaceholders} WHERE "{sqlPrimaryKeyColumn}" = $1`

	if _, err := tx.ExecContext(ctx, query, primaryKey, {goUpdateValues}); err != nil {
		return err
	}

	return nil
}

func ({goEntityName}Table) Delete(ctx context.Context, tx *sql.Tx, primaryKey string) error {
	const query = `DELETE FROM "{sqlTableName}" WHERE "{sqlPrimaryKeyColumn}" = $1`

	if _, err := tx.ExecContext(ctx, query, primaryKey); err != nil {
		return err
	}

	return nil
}

func ({goEntityName}Table) Copy(from *{goEntityName}, to any) error {
	return copier.Copy(&to, from)
}