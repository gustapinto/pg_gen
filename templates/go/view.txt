// Code generated by pg_gen, DO NOT EDIT.
package {goPackageName}

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

type {goEntityName} struct {
	{goEntityFields}
}

type {goEntityName}View struct{}

func ({goEntityName}View) Count(ctx context.Context, db *sql.DB, opts *SelectOptions) (uint, error) {
	query := `SELECT count(*) FROM "{sqlTableName}"`

	var values []any
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			values = v
		}
	}

	row := db.QueryRowContext(ctx, query, values...)
	if row.Err() != nil {
		return 0, row.Err()
	}

	var count uint
	if err := row.Scan(&count); err != nil {
		return 0, err
	}

	return count, nil
}

func ({goEntityName}View) Select(ctx context.Context, db *sql.DB, opts *SelectOptions) (*SelectResult[{goEntityName}], error) {
	query := `SELECT {sqlSelectFields} FROM "{sqlTableName}"`

	var values []any
	if opts != nil {
		filterPart, v := opts.toWherePartAndValues()
		if filterPart != "" {
			query += filterPart
		}

		if v != nil {
			values = v
		}

		if orderByPart := opts.toOrderByPart(); orderByPart != "" {
			query += orderByPart
		}

		if limitPart := opts.toLimitOffsetPart(); limitPart != "" {
			query += limitPart
		}
	}

	total, err := {goEntityName}View{}.Count(ctx, db, opts)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query, values...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := &SelectResult[{goEntityName}]{
		Total:    total,
		Selected: 0,
		Rows:     []{goEntityName}{},
	}

	for rows.Next() {
		var entity {goEntityName}
		if err := rows.Scan({goSelectManyScanFields}); err != nil {
			return nil, err
		}

		result.Rows = append(result.Rows, entity)
		result.Selected++
	}

	return result, nil
}
